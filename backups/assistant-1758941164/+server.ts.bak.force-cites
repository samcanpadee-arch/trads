/* Assistant: Hybrid + Responses File Search with Vector Store
   - Upload PDFs to OpenAI (purpose=assistants)
   - Create a vector store, attach files, wait until indexed
   - Call Responses API with tools:[{ type:"file_search", vector_store_ids:[...] }]
   - Hybrid: general knowledge + doc enrichment; request inline citations
*/
import type { RequestHandler } from "@sveltejs/kit";
import { env as privateEnv } from "$env/dynamic/private";

export const config = { runtime: 'nodejs20.x' };

async function uploadToOpenAI(file: File, apiKey: string): Promise<{ id: string; filename: string }> {
  const form = new FormData();
  form.append("purpose", "assistants");
  form.append("file", file, file.name || "upload.pdf");

  const resp = await fetch("https://api.openai.com/v1/files", {
    method: "POST",
    headers: { Authorization: `Bearer ${apiKey}` },
    body: form
  });
  if (!resp.ok) throw new Error(`OpenAI file upload failed: ${await resp.text()}`);
  const json = await resp.json();
  return { id: json.id as string, filename: (json.filename as string) || file.name || "upload" };
}

async function createVectorStore(apiKey: string, name: string): Promise<string> {
  const resp = await fetch("https://api.openai.com/v1/vector_stores", {
    method: "POST",
    headers: { Authorization: `Bearer ${apiKey}`, "Content-Type": "application/json" },
    body: JSON.stringify({ name })
  });
  if (!resp.ok) throw new Error(`Create vector store failed: ${await resp.text()}`);
  const json = await resp.json();
  return json.id as string;
}

async function attachFileToVectorStore(apiKey: string, vectorStoreId: string, fileId: string): Promise<void> {
  const resp = await fetch(`https://api.openai.com/v1/vector_stores/${vectorStoreId}/files`, {
    method: "POST",
    headers: { Authorization: `Bearer ${apiKey}`, "Content-Type": "application/json" },
    body: JSON.stringify({ file_id: fileId })
  });
  if (!resp.ok) throw new Error(`Attach file to vector store failed: ${await resp.text()}`);
}

async function waitForIndexing(apiKey: string, vectorStoreId: string, timeoutMs = 20000): Promise<void> {
  const start = Date.now();
  while (Date.now() - start < timeoutMs) {
    const resp = await fetch(`https://api.openai.com/v1/vector_stores/${vectorStoreId}/files?limit=100`, {
      headers: { Authorization: `Bearer ${apiKey}` }
    });
    if (!resp.ok) throw new Error(`Vector store poll failed: ${await resp.text()}`);
    const json = await resp.json();
    const files = (json.data || []) as Array<any>;
    if (files.length) {
      const pending = files.find((f) => f.status !== "completed");
      if (!pending) return; // all completed
    }
    await new Promise((r) => setTimeout(r, 800));
  }
  // time out: continue anyway
}

function extractTextFromResponses(resJson: any): string {
  if (!resJson) return "";
  if (typeof resJson.output_text === "string" && resJson.output_text.trim()) return resJson.output_text;
  if (Array.isArray(resJson.output)) {
    const texts: string[] = [];
    for (const item of resJson.output) {
      const parts = item?.content || item?.contents || [];
      for (const p of parts) {
        if (p?.type === "output_text" && typeof p?.text === "string") texts.push(p.text);
        if (p?.type === "text" && typeof p?.text === "string") texts.push(p.text);
      }
    }
    if (texts.length) return texts.join("\n");
  }
  if (Array.isArray(resJson.content)) {
    const first = resJson.content.find((c: any) => typeof c?.text === "string");
    if (first?.text) return first.text;
  }
  return "";
}

export const POST: RequestHandler = async ({ request }) => {
  try {
    if (!privateEnv.OPENAI_API_KEY) return new Response("Missing OPENAI_API_KEY", { status: 500 });

    const ctype = request.headers.get("content-type") || "";
    if (!ctype.includes("multipart/form-data")) {
      return new Response("Send multipart/form-data with fields: message and optional trade, brand, model, files[]", { status: 400 });
    }

    const form = await request.formData();
    const message = (form.get("message") as string || "").trim();
    const trade = (form.get("trade") as string || "").trim();
    const brand = (form.get("brand") as string || "").trim();
    const model = (form.get("model") as string || "").trim();
    if (!message) return new Response("Please include a question in 'message'.", { status: 400 });

    // Upload files (optional)
    const files = form.getAll("files").filter((f) => f instanceof File) as File[];
    const uploaded: Array<{ id: string; filename: string }> = [];
    for (const f of files) {
      try {
        const res = await uploadToOpenAI(f, privateEnv.OPENAI_API_KEY);
        uploaded.push(res);
      } catch (e: any) {
        console.error("Upload failed", e);
        return new Response(`File upload error: ${e?.message || e}`, { status: 500 });
      }
    }

    // Create vector store + attach files
    let vectorStoreId: string | null = null;
    if (uploaded.length) {
      vectorStoreId = await createVectorStore(privateEnv.OPENAI_API_KEY, `tradie-assistant-${Date.now()}`);
      for (const u of uploaded) {
        await attachFileToVectorStore(privateEnv.OPENAI_API_KEY, vectorStoreId, u.id);
      }
      await waitForIndexing(privateEnv.OPENAI_API_KEY, vectorStoreId);
    }

    const SYSTEM = `You are a technical assistant for experienced Australian tradies.
Provide precise, technical answers. Use general knowledge freely.
If attached manuals are relevant, incorporate their specifics and include concise inline citations like [Panasonic VKR Manual, p.12].
If no relevant manual context exists, do not refuse—answer from knowledge. Include safety/compliance notes when relevant.`;

    const userText = [
      trade ? `Trade: ${trade}` : null,
      brand ? `Brand: ${brand}` : null,
      model ? `Model: ${model}` : null,
      `Question: ${message}`,
      "Task:",
      "- Answer in technical detail (assume trade knowledge).",
      "- If any attached manual content is used, include at least one inline citation like [<short doc name>, p.X].",
      "- End with a short checklist."
    ].filter(Boolean).join("\n");

    // Build Responses API request
    const tools: any[] = [];
    if (vectorStoreId) {
      tools.push({
        type: "file_search",
        vector_store_ids: [vectorStoreId]
      });
    }

    const resp = await fetch("https://api.openai.com/v1/responses", {
      method: "POST",
      headers: {
        Authorization: `Bearer ${privateEnv.OPENAI_API_KEY}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: "gpt-4.1-mini",
        input: [
          { role: "system", content: [{ type: "input_text", text: SYSTEM }] },
          { role: "user", content: [{ type: "input_text", text: userText }] }
        ],
        tools,
        temperature: 0.2
      })
    });

    if (!resp.ok) {
      const msg = await resp.text();
      console.error("OpenAI Responses error", msg);
      return new Response(`OpenAI error: ${msg}`, { status: 500 });
    }

    const data = await resp.json();
    const text = extractTextFromResponses(data) || "Sorry — I couldn’t produce an answer.";
    return new Response(text, { status: 200, headers: { "Content-Type": "text/plain; charset=utf-8" } });
  } catch (outer: any) {
    console.error("Unhandled /api/assistant error", outer);
    return new Response(`Internal error: ${outer?.message || outer}`, { status: 500 });
  }
};
